# 🖥 Section 7. 가상 메모리

## 📍 가상메모리 개요

1. 가상 메모리란?
- 실행 시켜야 할 프로세스가 메모리의 크기보다 크다면 원래라면 해당 프로세스는 실행 시킬 수 없다.
- 하지만 프로세스는 운영체제 영역이 어디 있는지, 물리 메모리의 크기가 얼마인지 몰라도 실행이 가능한데, 이를 가능하게 해주는 시스템이 가상 메모리 시스템이다.
- 가상 메모리 시스템에서는 메모리와 하드디스크의 스왑영역을 합쳐서 그곳의 물리주소를 프로세스가 사용하게 될 가상 주소로 계산하여 사용한다.
- 이때 메모리 관리자는 가상 주소와 물리 주소를 일대일 매핑 테이블로 관리하여 물리주소와 가상 주소 사이 변환을 계산한다.
- 이를 통해 모든 프로세스는 0x00번지에서 시작된다고 가정하며, 개발자는 실제 물리주소를 신경쓰지 않고 프로그래밍 할 수 있다.

2. 가상 메모리 크기
- 이론적으로는 무한대이지만 실제로는 물리 메모리의 크기와 CPU의 비트 수로 결정된다.
- 만약 32bit CPU라면 표현할수 있는 주소값은 2^32로 약 4GB의 메모리까지 가용할 수있으며 가상메모리의 크기도 약 4GB이다.
(만약 실행시켜야 하는 프로세스들이 메모리 크기 보다 크다면 하드디스크의 스왑영역을 이용한다.)

3. 동적 주소 변환
- 메모리 관리자가 물리 메모리와 스왑영역을 합친 물리 주소를 프로세스가 사용하는 가상 주소로 변환하는 것을 동적 주소 변환(DAT)이라고 한다.
- 동적 주소 변환을 거치면 프로세스는 마음대로 사용자 데이터를 물리 메모리에 배치할 수 있다.
- 메모리 관리자는 전체적인 가상 메모리 시스템을 관리하는 역할을 하므로 처리해야하는 작업이 많다.
- 메모리 관리자는 일대일 매핑 테이블을 통해 물리 메모리에 저장되어 는 데이터와 스왑 영역에 저장되어 있는 데이터를 관리한다.

4. 가상 메모리 분할
- 실제 물리주소 0번지는 운영체제 영역이므로 프로세스가 사용할 수 없다.
- 가상 메모리 시스템에서는 운영체제 영역을 제외한 나머지 영역을 일정한 크기로 나눠서 프로세스에게 할당한다. 
  할당하는 방식은 메모리 분할과 마찬가지로 가변 분할 방식(세그멘테이션)과 고정 분할 방식(페이징)으로 나뉜다.
- 그러나 세그멘테이션에서는 외부 단편화라는 단점이 존재하고 페이징에는 내부 단편화라는 단점이 존재한다.
- 현재의 운영체제에서는 주로 이를 보안한 세그멘테이션-페이징 혼용 기법을 사용한다.

## 📍 세그멘테이션

1. 세그먼테이션이란?
- 세그멘테이션에서 프로그램은 함수나 모듈등으로 세그먼트를 나누어 구성한다. 
  프로그램 입장에서 볼때 메인 코드가 있는 코드 세그먼트, 전역 변수가 있는 데이터 세그먼트, 힙 영역에 있는 힙 세그먼트, 지역변수가 있는 스택 세그먼트 등으로 나뉜다.
- 여기서 각 세그먼트들은 서로 인접하지 않아도 되지만, 프로세스 관점에서는 코드 영역, 데이터 영역, 힙 영역, 스택 영역들이 서로 인접한 것 처럼 바라본다.
- 사용자, 프로세스, CPU가 쓰는 주소는 논리 주소이며, 이 때 메모리 관리자는 CPU와 메모리 중간에서 논리주소를 물리 주소로 변환해주는 역할을 수행한다.
- 메모리 관리자는 메모리 내에 있는 세그멘테이션 테이블을 이용해 논리주소와 물리 주소 사이를 변환하는데, 
  세그먼테이션 테이블에는 Base Address와 Bound Address가 있으며 이 두개의 데이터를 이용하여 물리 주소를 계산한다.
  
2. 메모리 관리자의 주소 변환 과정
    1. CPU가 메모리 관리자에게 논리주소를 물리주소로 변환하기를 요청한다면 메모리 관리자는 이 논리 주소가 몇번 세그먼트인지 알아낸다.
    2. 메모리 관리자 내에 Segment Table Base Register를 이용해 물리 메모리 내의 세그멘테이션 테이블을 찾는다.
    3. 세그먼트 번호를 이용해 Base 주소와 Bound 주소를 찾는다.
    4. Bound 주소는 세그먼트의 크기를 나타내는데, 이를 비교 논리주소와 비교하여 메모리를 침범했는지 확인한다.
       - 만약 논리 주소가 바운드 주소보다 작다면 Base 주소 + 논리주소를 통해 물리 주소의 값을 구한다.
       - 만약 논리 주소가 바운드 주소보다 크다면 메모리를 침범했다고 생각하고 에러를 발생(인터럽트 발생시켜 프로세스를 강제 종료)시킨다.

    ※ 메모리 관리자는 컨텍스트 스위칭을 할때마다 Segment Table Base Register를 해당 프로세스의 것으로 바꿔주어야 한다.
       컨텍스트 스위칭은 이러한 작업들을 수행하기 때문에 굉장히 무거운 동작이다.

3. 세그먼테이션 기법의 장단점
- 장점 : 각 영역을 모듈로 처리해서 공유와 각 영역에 대한 메모리 접근 보호가 편리하다.
- 단점 : 가변 분할 방식의 단점인 외부 단편화가 발생한다.

## 📍 페이징 (배치 정책)

1. 페이징이란?
- 고정 분할 방식 (세그멘테이션 기법)은 외부 단편화 문제가 있기 때문에 이를 해결하기 위해 고안.
  (외부 단편화를 해결하기 위한 조각모음은 오버헤드가 너무 크다.)
- 페이징은 메모리를 할당할 때 정해진 크기의 페이지로 나눠 모든 페이지의 크기가 동일하다.
- 이로 인해 관리가 굉장히 쉬우며, 또한 일정한 크기로 나눴기 때문에 외부 단편화가 일어나지 않는다.
- 페이징에서 논리 주소 공간을 일정한 크기로 균일하게 나누는데 이를 페이지라고 하며, 
  물리 주소 공간(실제 물리 메모리 공간)도 페이지 크기와 동일하게 나누는데 이를 프레임이라고 한다.

2. 페이징의 주소 변환
    - 세그멘테이션과 마찬가지로 메모리 관리자는 페이지 테이블을 사용한다.
    1. CPU가 논리 주소를 알려주면 메모리 관리자는 몇번 페이지, 오프셋은 몇인지 알아낸다.
    2. 메모리 관리자 내의 Page Table Base Register(PTBR)를 이용해 물리 메모리 안에 있는 페이지 테이블을 알아온다.
    3. 페이지 번호를 인덱스로 프레임 번호를 알아낸다
    4. 오프셋을 이용해 물리 주소로 변환을 한다.
        - 페이지 테이블에 Invalid로 표시되어 있으면 하드디스크의 스왑영역에 저장되어 있다는 의미이다
    - 세그멘테이션 테이블과 마찬가지로 Page Table Base Register는 컨텍스트 스위칭이 일어날 때 마다 해당 프로세스의 페이지 테이블로 업데이트 한다.
  
3. 세그멘테이션과 페이징의 차이점 = 페이지의 크기
    - 세그멘테이션은 프로세스마다 크기가 달라 Bound Address를 갖고 있지만 페이징은 모든 페이지의 크기가 동일해서 Bound Address가 필요없다.
    - 이런 특징 때문에 페이징은 외부 단편화는 발생하지 않지만 내부 단편화가 발생한다.
    - 그러나 외부 단편화와 비교했을땐 더 효율적이다. (내부 단편화를 해결하는 것이 더 쉬움)
    - 세그멘테이션은 논리적인 영역별로 세그먼트를 나눈다.(코드영역, 데이터 영역, 스택영역, 힙영역...)
    - 그러나 페이징은 페이지의 크기가 고정되어 있어 논리적인 영역으로 나눌 수 없으므로 특정 영역만 공유하거나 권한을 부여하는 것이 어렵다.
  
4. 페이지 테이블의 크기
    - 페이징 기법은 각 프로세스마다 페이지 테이블을 지니고 있는데, 메모리 관리자가 참조하는 페이지 테이블도 물리 메모리의 운영체제 영역에 저장되어 있다.
    - 그러므로 페이지 테이블 크기가 너무 크면 사용자 영역이 부족하게 되므로 무의미한 공간이 낭비되지 않도록 페이지 테이블 크기를 적절하게 유지하는 것이 중요하다.

## 📍 페이지드 세그멘테이션 (배치 정책)

1. 페이지드 세그멘테이션이란?
- 세그멘테이션 + 페이징의 장점만 혼합한 방식
- 세그멘테이션 장점 : 가변분할 방식이라 코드, 데이터, 힙, 스택영역들을 세그먼트로 나눠서 관리할 수 있다. 
  그래서 다른 프로세스와 공유하기도 편하고 각 영역에 대한 메모리 접근 보호를 하기 쉽다
- 페이징의 장점 : 고정분할 방식이라 메모리를 효율적으로 관리할 수 있다.

2, 메모리 접근 권한
- 메모리의 특정주소에는 읽기(Read), 쓰기(Write), 실행(Execute) 3가지 권한이 있다
- 프로세스 또한 각 영역마다 접근 권한이 존재한다.

3. 메모리 접근 권한에 대한 검사
- 메모리 접근 권한에 대한 검사는 메모리 관리자가 가상주소를 물리주소로 변환할때 발생하며, 만약 권한을 위반하면 에러를 발생시킨다.

4. 페이지드 세그멘테이션
- 페이지드 세그멘테이션은 테이블이 세그멘테이션 테이블, 페이지 페이블로 2개 존재한다.
- 이전까지의 방식에서는 세그멘테이션에서 세그멘테이션 테이블은 Base Address(해당 세그먼트의 시작주소)와 Bound Address(해당 세그먼트의 크기)로 구성되었고 
  페이징 기법에서 페이지 테이블은 프레임 번호로 구성되어 있다.
- 페이지드 세그멘테이션 기법에서는 세그멘테이션 테이블에 권한 비트를 추가한다. 
  Base Address는 페이지 넘버로 바뀌고 Bound Address는 페이지 갯수로 바뀐다. 이름만 달라졌을뿐 하는 역할은 달라지지 않는다.

5. 주소 변환 절차
    1. 가상 주소가 들어오면 메모리 관리자는 몇번 세그먼트인지 알아낸다.
    2. 세그멘테이션 테이블을 이용해 해당 세그먼트가 메모리 접근 권한을 위반하는지 검사
    3. 세그멘테이션 테이블에 따라 페이지 넘버와 페이지 갯수를 참조
    4. 페이지 넘버로 페이지 테이블의 인덱스에 접근하여 프레임 번호를 가져온다.
    5. 물리 메모리 내의 해당 프레임에 접근하여 그 위치에서 페이지 갯수를 더해 물리주소를 구한다.
       (만약 물리메모리에 해당 프레임이 없다면 스왑영역에서 참조)

6. 페이지드 세그멘테이션의 단점
- 물리 메모리에 접근하기 위해 메모리에 접근을 두번 해야 한다.(세그멘테이션 테이블 참조, 페이지 테이블 참조)
- 이런 이유로 현대 운영체제는 페이징과 페이지드 세그멘테이션 기법을 적절이 섞어서 사용.

## 📍 디맨드 페이징 (가져오기 정책)
1. 지역성 이론
    - 공간의 지역성 : 현재 위치와 가까운 데이터에 접근활 확률이 높다는 이론.
    - 시간의 지역성 : 최근 접근했던 데이터가 오래 전에 접근했던 데이터보다 접근할 확률이 높다는 이론.
    ex) goto문 : 지역성 이론에 따라 성능이 좋지 않아 사용 지양
      
2. 디맨드 페이징
    - 조만간 쓰일 것 같은 데이터는 메모리로 가져오고 사용하지 않을 것 같은 데이터는 스왑영역으로 이동시켜 지역성 이론을 구현한 정책
    - 메모리에 접근하는 시간이 레지스터 -> 보조저장장치로 갈수록 느려지므로 디맨드 페이징은 이 시간을 효율적으로 관리하는 것을 목적으로 한다.
    - 스왑 인 (swap in) : 물리 메모리에서 스왑 영역으로 데이터를 가져오는 것
    - 스왑 아웃 (swap out) : 물리 메모리에서 스왑 영역으로 데이터를 보내는 것
    
3. 페이지 테이블
-  PTE(페이지 테이블 엔트리) : 페이지 테이블을 이루고 있는 한 행. 프레임 넘버로 구성되어 있을 분만 아니라 여러 비트로 구성되어 있음.
   - 접근 비트, 변경 비트, 유효 비트, 읽기/쓰기/실행 비트(해당 비트에 접근 권한이 있는지 검사), 프레임
-  페이지 테이블을 통해 데이터의 주소를 검색했으나 만약 메모리에 원하는 데이터가 없을 경우 
   Page Fault라는 인터럽트를 발생시켜 만약 메모리에 원하는 데이터가 없는 경우 스왑 영역에서 메모리로 가져오는 스왑 인이 발생함.

## 📍 페이지 교체 정책
- 메모리가 꽉 찼을 때 어떤 데이터를 스왑 영역으로 보낼 것인지 결정하는 정책을 말한다.
1. Random
    - 랜덤으로 선택. 비효율적이라 거의 사용하지 않음
2. FIFO (First In First Out)
    - 제일 공평한 방법이지만 많이 쓰이는 데이터가 교체될 경우 비효율성을 초래할 수 있음.
    - 구현이 간단하고 성능이 괜찮아서 변형해서 많이 쓰임.
3. Optimum
    - 미래를 예측하여 가장 쓰이지 않을 것 같은 페이지 교체
    - 실제로 구현 불가능. 이론적인 선택방법이지만 다른 교채 알고리즘의 성능 비교 및 측정하는 지표로 사용됨.
4. LRU (Least Recently Used)
    - 최근에 가장 사용을 적게 한 페이지를 우선적으로 교체하는 방법
    - 실제로 Optimum과 거의 비슷한 성능을 가지고 있다고 증명됨.
    - 지역성 이론을 적용하지 않으면 비효율성이 높아질 수 있음.
    
* 빌레이디의 역설
- 페이지 폴트를 줄이려고 메모리를 늘려 프레임의 개수를 증가시켰지만 오히려 페이지 폴트가 더 많이 발생하는 현상
- FIFO에서는 발생할 수 있으나 LRU에서는 발생하지 않음.
- 하지만 LRU는 시간을 측정하는 비트를 저장해야 하므로 추후 오버플로우가 발생할 우려가 있음. 

5. Clock Algorithm
- LRU의 단점을 보완
- 클락 알고리즘은 페이지를 원형으로 연결하여 클락 핸드를 사용하여 시계방향으로 돌면서 이 페이지가 전에 참조되었는지 참조되었는지를 접근 비트로 판단하여 데이터를 관리함.
- 접근 비트가 0인 페이지를 스왑 영역으로 보내는 방식.
- 좀 더 향상된 클락 알고리즘은 변경비트를 두어 접근비트와 변경비트가 둘 다 0인 페이지를 우선적으로 스왑 영역으로 보냄.

6. 향상된 FIFO (2차 기회 페이지 교체 알고리즘)
- LRU를 구현하기 힘든 상황에서 부득이하게 FIFO를 사용해야 하는 시스템에서 효율적으로 FIFO 알고리즘을 사용하기 위해 고안
- 자주 사용하는 페이지에게 한번의 기회를 더 주는 알고리즘으로, 만약 페이지 폴트 없이 페이지 접근에 성공했다면 해당 페이지를 큐의 맨 처음으로 이동시켜 다음 페이지 폴트 발생 시 
변경되는 페이지로 선택되지 않게끔 한다.
- 해당 방식은 LRU보다는 비효율적이고 FIFO보다는 효율적이다.

## 📍 스레싱과 워킹셋
1. 스레싱
    - 물리 메모리의 크기에는 한계가 있기 때문에 모든 프로세스를 물리 메모리에 올릴 수 없음. 이렇게 되면 스왑 영역을 사용하여 프로세스를 저장하게 되는데,
      만약 실행하려는 프로세스가 메모리에 저장되어 있지 않은 경우, 페이지 폴트가 발생하게 되고 스왑 영역에 있는 데이터를 가져오고 내보내는 작업을 처리해야 함. (스왑 인 / 스왑 아웃)
      지속해서 페이지 폴트가 발생하는 경우 CPU의 작업 시간보다 스왑 작업의 시간이 길어지게 되고, 이 경우 CPU의 사용률이 줄어들게 됨.
    - CPU 사용률을 높이려 했으나 오히려 CPU의 사용률이 더 하락하는 현상을 스레싱이라고 함.
      (CPU의 사용률을 늘리고자 프로레스의 개수를 증가시켰으나 스왑 작업의 시간이 더 길어져 결국 CPU의 사용률이 계속 하락하는 것)
    - 스레싱의 근본적인 원인은 물리 메모리의 크기가 부족하기 때문. 하지만 메모리의 크기를 무작정 늘린다고 CPU의 사용률이 증가하지는 않음.
2. 워킹셋
    - 스레싱의 발생은 줄이고 CPU의 사용률을 늘리기 위해 소프트웨어적으로 해결 방법을 고안한 것
    - 주기적으로 페이지 폴트의 발생 횟수를 모니터링하여 할당된 페이지의 수를 조절하는 것.
    - 현재 메모리에 올라온 페이지는 다시 사용할 확률이 높기 때문에 하나의 세트로 묶어서 메모리에 올리는데 이를 워킹셋이라고 함.
    - 워킹셋은 프로세스가 준비 상태에서 실행 상태가 되는 컨텍스트 스위칭을 할 때 사용함.