# 🖥 Section 6. 메모리

## 📍 메모리 종류
1. 레지스터 (Register)
    - 32bit Register, 64Bit Register
    - 휘발성. 메인 메모리에 있는 값을 가져와 계산한 후 다시 메모리에 저장함.
2. 캐시 메모리 (Cache)
    - 휘발성.
    - CPU가 사용하는 메모리로 빠른 속도가 특징.
    - 메인 메모리에 있는 것을 레지스터로 가져오는데 오랜 시간이 걸리므로 자주 사용하는 데이터를 미리 캐시 메모리에 저장함.
    - 캐시 메모리는 L1, L2, L3 캐시로 보통 이루어져 있으며, 사용 빈도에 따라 저장되는 캐시 메모리 위치가 다름.
3. 메인 메모리 (RAM)
    - 실제 운영체제와 다른 프로세스들이 올라가는 공간.
    - 전원이 공급되지 않으면 데이터가 지워짐. 휘발성
    - 속도는 빠르지만 비쌈.
    - 데이터를 저장하기 보다는 실행중인 프로그램을 저장함.
4. 보조 저장장치 (HDD,SSD)
    - 비휘발성. 가격이 저렴함. 데이터 저장에 활용
    - 하드디스크의 용량만큼 메인 메모리 용량을 할당하려면 어마어마한 비용이 소모됨.
    
<br>

## 📍 메모리와 주소
- 운영체제는 메모리를 관리하기 위해 1byte의 크기로 나누어 관리하는데 이것을 주소라고 함.
- Register의 크기에 따라 산술논리연산장치(ALU)의 크기도 결정됨 (32bit/64bit)
- 물리 주소 공간 : 메모리를 컴퓨터에 연결하면 0x0번지부터 시작하는 주소 공간
- 논리 주소 공간 : 사용자가 접근하는 주소 공간. 논리 주소 공간을 활용하여 물리 주소에 접근 가능함.
- `경계 레지스터` : 하드웨어적으로 운영체제 공간과 사용자 공간을 나누는 CPU 내의 레지스터. 메모리 관리자가 사용자 프로세스가 경계 레지스터 값을 벗어났는지 검사하고 만약 벗어났다면 그 프로세스를 종료시킴.

### 절대 주소와 상대 주소
- 개발자는 프로그램을 만들 때 프로그램이 실행될 주소를 신경쓰지 않고 개발함. 이는 컴파일러가 메모리 0번지에서 실행한다고 가정하기 때문.
- 개발자의 프로그램을 실행시켜 메모리에 올라왔다고 가정했을 때, 컴파일러가 인식하는 주소(0x0)와 실제 메모리에 올라온 주소(0x4000)는 다름
- 사용자가 바라본 주소는 상대 주소(논리 주소) 공간이라고 하고, 메모리 관리자가 바라본 주소는 물리 주소 공간이라고 함.
- 메모리 관리자는 CPU의 요청을 받으면 재배치 레지스터에 저장되어 있는 프로그램 시작 주소를 참고하여 실제 물리 주소를 계산하여 접근하고 CPU에게 데이터를 제공함.

<br>

## 📍 메모리 할당방식
1. 메모리 오버레이 (Memory Overlay)
    - 큰 프로그램을 작게 나누어 일부만 실행하고 나머지 프로그램은 하드디스크에 저장하는 것.
    - 정확히는 하드 디스크의 스왑 영역에 저장됨. 
    
2. SWAP
    - 스왑 영역에 있는 데이터 일부를 메모리로 가져오고 메모리에 있는 데이터를 스왑영역으로 옮기는 것
    - 스왑 과정이 있기 때문에 실제 메모리에 전부 적재되어 있는 것 보다는 느리게 동작함.
      
3. 메모리 할당 방식
    1. 가변 분할 방식
        - 프로세스의 크기에 따라 메모리를 나누는 방식
        - 한 프로세스가 메모리에 연속된 공간에 할당되기 때문에 `연속 메모리 할당`이라고도 함.
        
    2. 고정 분할 방식
        - 프로세스의 크기와 상관 없이 메모리를 일정 크기로 나누어 할당하는 방식
        - 정해진 크기보다 프로세스의 전체 크기보다 작을 경우 낭비 공간이 발생함.
        - 한 프로세스가 메모리에 분산되어 할당되기 때문에 `비연속 메모리 할당`이라고도 함.
    
    3. 장단점
        1. 가변 분할 방식
            - 프로세스의 크기에 딱 맞게 할당되므로 낭비되는 공간인 내부 단편화가 발생하지 않음.
            - 외부 단편화 발생 위험 존재
        2. 고정 분할 방식
            - 구현이 간단하고 오버헤드가 적음.
            - 내부 단편화 발생
       
    4. 오늘날의 운영체제의 메모리 할당 방식은 위 두가지 방식을 혼합하여 사용
    
4. 세그멘테이션 (가변 분할 방식)
    - `외부 단편화`
        - 처음 할당할 때에는 문제가 발생하지 않으나 프로세스가 종료되고 다시 빈공간이 발생했을 경우 그 빈공간에 맞는 프로세스가 생성되기 전까지 대기하거나 빈공간에 딱 맞는 프로세스가 존재하지 않아 낭비 공간이 발생하는 것.
    
5. 페이징 (고정 분할 방식)
    - `내부 단편화`
        - 분할된 크기보다 작아서 낭비 공간이 발생하는 것.
        - 분할 크기를 조절해 내부 단편화를 최소화할 수 있음.
    
5. 버디 시스템 
    - 세그먼테이션과 페이징을 혼합하여 단점을 최소화한 방법 
    - 2의 승수로 메모리르 분할하여 메모리를 할당하는 방식
    - 프로세스를 할당할 수 있을 때까지 2의 승수로 나눈 후 프로세스를 할당하는 방법
    - 2의 승수로 동일하게 나누기 때문에 조립만 하면 쉽게 분할한 메모리를 합칠 수 있으므로 조각모음보다 훨씬 간단.
    - 내부 단편화가 발생하기는 하지만 많은 공간의 낭비가 발생하지는 않음.
    - 가변 분할 방식처럼 프로세스마다 할당된 메모리 크기가 달라질 수 있으며, 외부 단편화를 방지하기 위해 메모리 공간을 확보하기 편함.